#include "QueExploit.h"

HWND Dota2                = FindWindow(0, _T("Dota 2") );
HDC hdcDota2              = GetDC(Dota2);
const double XRES         = (double) GetSystemMetrics(SM_CXSCREEN);
const double YRES         = (double) GetSystemMetrics(SM_CYSCREEN);
const double XSCALEFACTOR = 65535.0 / (XRES - 1);
const double YSCALEFACTOR = 65535.0 / (YRES - 1);
POINT stopQue             = { long ( 1843.0 /  1920.0 * (double) XRES ), long ( 1037.0 /  1080.0 * (double) YRES )}; // dota 2 cancel que button Location 1920x1080 res (1843, 1037)
POINT startQue            = { long ( 1677.0 /  1920.0 * (double) XRES ), long ( 1035.0 /  1080.0 * (double) YRES )}; // point to click to start que 1677, 1035
POINT defocus             = { long ( 1510.0 /  1920.0 * (double) XRES ), long ( 1039.0 /  1080.0 * (double) YRES )}; // point to click to de-focus play dota button 1510, 1039
RGBQUAD CancelRGB         = { 2, 6, 57 };     // color at point stopQue when not hovered on X button (reversed rgb) 9, 20, 72 | 57, 6, 2
RGBQUAD CancelRGB2        = { 3, 10, 74 };    // color at POINT stopQue when hovered on X button (reversed rgb) 3, 10, 74
RGBQUAD PlayBtnRGB        = { 255, 255, 255 }; // color at POINT startQue when gray (not focused)
RGBQUAD PlayBtnRGB2       = { 114, 173, 105 }; // color at POINT defocus when green (focused) // reversed RGB
bool QueStatus            = false;
int QueState              = 0;
bool shouldBeQueueing;

RGBQUAD getPixel(int x, int y) { //must have HDC hdcDota2

    HDC hdcTemp;
    RECT rect;
    RGBQUAD* bitPointer;
    RGBQUAD hex_color; // return value

    //hdc = GetDC(Screen);
    GetWindowRect(Dota2, &rect);
    int MAX_WIDTH = rect.right;
    int MAX_HEIGHT = rect.bottom;

    hdcTemp = CreateCompatibleDC(hdcDota2);
    BITMAPINFO bitmap;
    bitmap.bmiHeader.biSize = sizeof(bitmap.bmiHeader);
    bitmap.bmiHeader.biWidth = MAX_WIDTH;
    bitmap.bmiHeader.biHeight = -MAX_HEIGHT;
    bitmap.bmiHeader.biPlanes = 1;
    bitmap.bmiHeader.biBitCount = 32;
    bitmap.bmiHeader.biCompression = BI_RGB;
    bitmap.bmiHeader.biSizeImage = 0;
    bitmap.bmiHeader.biClrUsed = 0;
    bitmap.bmiHeader.biClrImportant = 0;

    HBITMAP hBitmap2 = CreateDIBSection(hdcTemp, &bitmap, DIB_RGB_COLORS, (void**)(&bitPointer), NULL, NULL);
    HBITMAP hbmpOld = (HBITMAP) SelectObject(hdcTemp, hBitmap2);
    BitBlt(hdcTemp, 0, 0, MAX_WIDTH, MAX_HEIGHT, hdcDota2, 0, 0, SRCCOPY);

    hex_color = bitPointer[(MAX_WIDTH * y ) + x ];

    SelectObject(hdcTemp, hbmpOld);
    DeleteObject(hBitmap2);
    DeleteDC(hdcTemp);
    return hex_color;
}

bool compare2Colors(RGBQUAD color1, RGBQUAD color2)
{
    return ( ( (int) color1.rgbRed == (int) color2.rgbRed ) && ( (int) color1.rgbGreen == (int) color2.rgbGreen ) && ( (int) color1.rgbBlue == (int) color2.rgbBlue ) );
}

bool isQueueing()
{
  RGBQUAD color = getPixel( (int) stopQue.x, (int) stopQue.y);
  return (deltaE76(color, CancelRGB) <= 6);
}

bool checkPixelForColor(POINT pixelPoint, COLORREF color)
{
    COLORREF currentColorAtPixel = GetPixel(hdcDota2, (int) ( (double) pixelPoint.x /  1920.0 * XRES ), (int) ( (double) pixelPoint.y /  1080.0 * YRES) );
    bool isPixelColor = ( ((int) GetRValue(color) == (int) GetRValue(currentColorAtPixel) ) && ( (int)GetGValue(color) == (int)GetGValue(currentColorAtPixel) ) && ( (int)GetBValue(color) == (int)GetBValue(currentColorAtPixel) ) );
    return isPixelColor;
}

bool set(bool* b, bool value)
{
    // if b isn't going to change
    if (*b == value) return false;

    // if b is going to change
    else
    {
        *b = value;
        return true;
    }
}

void QueOFF()
{
    if (QueStatus == 1) {
            LOG("Stopping Que");
            click( (int) defocus.x, (int) defocus.y );
            click( (int) stopQue.x, (int) stopQue.y );
            LOG("Stopped Que");
            return;
    }
    Sleep(10);
    QueOFF();
}

void QueON()
{
   if( QueStatus == 1) { LOG("Already started que!");  return; }
   if( QueState == 0 ) { return; }
   // SetForegroundWindow(Dota2);
   LOG("Starting que");
    click( (int) defocus.x, (int) defocus.y ); // DE-focus dota "PLAY button"
    Sleep(500);
    click( (int) startQue.x, (int) startQue.y );
    Sleep(500);
    click( (int) startQue.x, (int) startQue.y );
   //Sleep(1000);
    if (QueStatus == 1) { LOG("Started que"); }
   //QueON();
}

double mathDistance(double a, double b)
{
    return ((a -b ) * (a - b));
} 

double deltaE76(RGBQUAD color1, RGBQUAD color2) 
{
    double Diff;
    Diff = mathDistance((double) color1.rgbRed, (double) color2.rgbRed) + mathDistance((double) color1.rgbGreen, (double) color2.rgbGreen) + mathDistance((double) color1.rgbBlue, (double) color2.rgbBlue);
    return sqrt(Diff) / 440 * 100;
}

void initConsole()
{
    HWND console = GetConsoleWindow();
    SetWindowPos(console, HWND_TOPMOST, 2, 399, 370, 300, SWP_DRAWFRAME | SWP_SHOWWINDOW);
    ShowWindow(console, SW_NORMAL);
}

void click(int x, int y)
{
    double nx = x * XSCALEFACTOR;
    double ny = y * YSCALEFACTOR;

    INPUT Input={0};
    Input.type = INPUT_MOUSE;
    Input.mi.dx = (LONG)nx;
    Input.mi.dy = (LONG)ny;
    Input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP;

    SendInput(1,&Input,sizeof(INPUT));
}

int getTime()
{
 return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now()).time_since_epoch()).count();
}